# Phase 1.4: 智能语音质量检测与交互优化需求文档

**版本**: 1.3 (全面优化版)
**日期**: 2026-01-23
**优先级**: 高
**状态**: 需求定义中

---

## 文档变更记录

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0 | 2026-01-22 | 初始版本（独立模块设计） | Claude |
| 1.1 | 2026-01-23 | 与现有架构整合 | Claude |
| 1.2 | 2026-01-23 | 简化设计：在状态机中直接实现 | Claude |
| 1.3 | 2026-01-23 | **纳入智能优化方案：自适应阈值、分级重试、LED反馈** | Claude |

---

## 1. 背景与问题分析

### 1.1 当前系统问题

**Phase 1.3 状态机现状**：

```
已有功能：
✅ 音频长度检测
✅ 音频能量检测（RMS）
✅ 无效词汇检测
✅ 文本长度验证
✅ 重复字符检测
✅ 多轮对话机制

存在问题：
❌ 检测规则硬编码（阈值固定）
❌ 简单重试机制（无分级策略）
❌ 缺少可视化反馈（用户不知道系统状态）
❌ VAD 阈值固定（环境变化时误触发多）
```

### 1.2 五大痛点与解决方案映射

| 痛点 | 根本原因 | 1.4 解决方案 | 优先级 |
|------|----------|-------------|--------|
| **环境噪音干扰** | VAD阈值固定，无法适应环境变化 | **自适应VAD阈值**：实时监测底噪，动态调整触发门槛 | P0 |
| **无效输入处理** | 缺少智能甄别机制 | **时长-能量双重校验**（已有）+ **语义完整性检查** | P0 |
| **断句零散输入** | 静音超时固定，未拼接断句 | **智能尾端点检测**：延长超时时间，拼接断句 | P1 |
| **交互反馈缺失** | 无状态可视化 | **LED可视化反馈**：利用ReSpeaker灯带显示系统状态 | P1 |
| **缺少重试机会** | 无分级容错 | **分级重试策略**：3级渐进式提示与兜底 | P0 |

### 1.3 设计原则

1. **渐进增强**：核心功能优先，高级特性可选
2. **轻量实现**：不引入重量级依赖（如 AI 降噪模型）
3. **硬件利用**：充分利用 ReSpeaker 和树莓派5的现有能力
4. **用户导向**：以提升用户体验为核心目标

---

## 2. 核心功能需求

### 2.1 自适应 VAD 阈值（P0）

#### 功能描述

系统实时监测环境底噪水平，动态调整 VAD 触发阈值，适应不同噪音环境。

#### 实现方案

```python
class AdaptiveVAD:
    """自适应 VAD 阈值管理器"""

    def __init__(self, config: dict):
        self._base_threshold = config.get("energy_threshold", 0.04)
        self._noise_samples = []  # 存储环境噪音样本
        self._max_samples = 100   # 样本窗口大小
        self._adaptation_factor = 1.5  # 阈值自适应系数

    def update_noise_floor(self, audio_chunk: np.ndarray) -> float:
        """
        更新环境底噪估计

        Args:
            audio_chunk: 音频块（静音期间采集）

        Returns:
            float: 当前估计的底噪能量
        """
        # 计算 RMS 能量
        energy = np.sqrt(np.mean(audio_chunk.astype(float) ** 2))

        # 更新底噪样本
        self._noise_samples.append(energy)
        if len(self._noise_samples) > self._max_samples:
            self._noise_samples.pop(0)

        # 计算底噪平均值
        noise_floor = np.mean(self._noise_samples)
        return noise_floor

    def get_adaptive_threshold(self) -> float:
        """
        获取自适应阈值

        Returns:
            float: 动态调整后的阈值
        """
        if not self._noise_samples:
            return self._base_threshold

        noise_floor = np.mean(self._noise_samples)
        # 阈值 = 底噪 × 自适应系数
        adaptive_threshold = max(self._base_threshold, noise_floor * self._adaptation_factor)
        return adaptive_threshold

    def reset(self) -> None:
        """重置底噪估计（用于环境变化时）"""
        self._noise_samples = []
```

#### 配置

```yaml
audio_quality:
  vad:
    # 自适应阈值配置
    adaptive_enabled: true           # 启用自适应阈值
    base_threshold: 0.04             # 基础阈值
    adaptation_factor: 1.5           # 自适应系数（阈值 = 底噪 × 系数）
    noise_window_size: 100           # 底噪样本窗口大小
    reset_interval: 300              # 重置间隔（秒）

  # 提示语配置
  prompts:
    high_noise:                      # 高噪音环境提示
      - "环境有点吵，请靠近一点说"
      - "检测到背景噪音，请安静一些"
```

#### 使用时机

- 在 IDLE 状态持续采集底噪样本
- 在 LISTENING 状态使用动态阈值检测语音
- 每隔 `reset_interval` 秒重置一次底噪估计

---

### 2.2 分级重试策略（P0）

#### 功能描述

实现三级渐进式重试机制，根据失败次数给出不同提示，提升容错率。

#### 重试流程

```
第 1 次失败
    ↓
提示："抱歉，没听清，能再说一遍吗？"
    ↓
返回 LISTENING

第 2 次失败
    ↓
提示："好像还是不太清楚，请大声一点或重新说一遍"
    ↓
返回 LISTENING

第 3 次失败
    ↓
提示："抱歉暂时无法识别，我们换个话题吧"
    ↓
返回 IDLE
```

#### 实现方案

```python
def _handle_invalid_input(self, issue_type: str) -> None:
    """
    处理无效输入：分级重试策略

    Args:
        issue_type: 问题类型 ("silence" | "fragment" | "semantic" | "garbage")
    """
    # 增加重试计数
    if not hasattr(self, '_retry_count'):
        self._retry_count = 0
    self._retry_count += 1

    config = self._config.get("audio_quality", {})
    max_retries = config.get("max_retries", 3)

    if self._retry_count >= max_retries:
        # 第 3 次失败：返回 IDLE
        self._retry_count = 0
        logger.info(f"达到最大重试次数 ({max_retries})，返回 IDLE")
        print(f"\n🔚 超过最大重试次数，返回待机模式\n")

        # 播放最终提示
        final_message = self._get_retry_prompt(max_retries, issue_type)
        self._play_tts_prompt(final_message)

        self.transition_to(State.IDLE)
    else:
        # 第 1 或 2 次失败：根据次数给出不同提示
        prompt = self._get_retry_prompt(self._retry_count, issue_type)
        logger.info(f"重试 {self._retry_count}/{max_retries}: {prompt}")
        print(f"\n🔔 {prompt}\n")

        self._play_tts_prompt(prompt)

        # 等待播放完成
        while self._feedback_player.is_playing():
            time.sleep(0.01)

        # 重新进入 LISTENING
        self.transition_to(State.LISTENING)

def _get_retry_prompt(self, retry_count: int, issue_type: str) -> str:
    """
    根据重试次数和问题类型获取分级提示语

    Args:
        retry_count: 当前重试次数 (1, 2, 或 3)
        issue_type: 问题类型

    Returns:
        str: 提示语
    """
    config = self._config.get("audio_quality", {})
    retry_prompts = config.get("retry_prompts", {})

    # 获取该问题类型的分级提示
    type_prompts = retry_prompts.get(issue_type, {})
    count_key = f"retry_{retry_count}"

    # 如果有配置对应次数的提示，使用配置
    if count_key in type_prompts:
        prompts = type_prompts[count_key]
    else:
        # 使用默认提示
        if retry_count < 3:
            prompts = ["抱歉，没听清，能再说一遍吗？"]
        else:
            prompts = ["抱歉暂时无法识别，我们换个话题吧"]

    # 随机选择
    import random
    return random.choice(prompts)
```

#### 配置

```yaml
audio_quality:
  max_retries: 3

  # 分级重试提示语
  retry_prompts:
    silence:                    # 静音/太短
      retry_1:
        - "抱歉，没听到您的声音，能再说一遍吗？"
        - "您刚才没说话，请再试一次"
      retry_2:
        - "还是没听到，请靠近麦克风大声一点说"
        - "好像还是不太清楚，请重新说一遍"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    fragment:                   # 断句/不完整
      retry_1:
        - "请完整说出您的问题"
        - "话说一半啦，继续说吧"
      retry_2:
        - "请说完整一点，不要断断续续的"
        - "能完整地再说一遍吗？"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    semantic:                   # 语义不明
      retry_1:
        - "抱歉，不太明白您的意思，能再说一遍吗？"
        - "能说得更清楚一点吗？"
      retry_2:
        - "还是不太理解，请换个方式描述"
        - "能详细说明一下您的需求吗？"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    garbage:                    # 乱码
      retry_1:
        - "抱歉，我没听清，能再说一遍吗？"
      retry_2:
        - "还是听不清楚，请重新说一遍"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"
```

---

### 2.3 LED 可视化反馈（P1，可选增强）

#### 功能描述

利用 ReSpeaker 的环形 LED 灯带，显示系统当前状态，提供直观的视觉反馈。

#### LED 状态定义

| 状态 | LED 效果 | 颜色 | 说明 |
|------|---------|------|------|
| **IDLE** | 呼吸效果 | 蓝色 | 待机/监听唤醒词中 |
| **WAKEUP** | 闪烁（快速） | 绿色 | 唤醒成功，播放反馈中 |
| **LISTENING** | 流动动画 | 青色 | 录音中 |
| **PROCESSING** | 常亮 | 黄色 | 处理中（识别/生成） |
| **SPEAKING** | 脉冲效果 | 绿色 | 播放回复中 |
| **ERROR** | 闪烁（快速） | 红色 | 错误/失败 |
| **RETRY_1** | 闪烁 1 次 | 橙色 | 第 1 次重试 |
| **RETRY_2** | 闪烁 2 次 | 橙色 | 第 2 次重试 |

#### 实现方案

```python
# src/feedback/led_feedback.py

class LEDFeedback:
    """LED 反馈控制器"""

    def __init__(self, config: dict):
        self._enabled = config.get("enabled", False)
        self._pin = config.get("pin", 12)  # GPIO 引脚号
        self._led_count = config.get("led_count", 12)

        if self._enabled:
            try:
                import board
                import neopixel
                self._pixels = neopixel.NeoPixel(
                    getattr(board, f"D{self._pin}"),
                    self._led_count,
                    brightness=0.5
                )
                self._available = True
            except ImportError:
                logger.warning("NeoPixel 库未安装，LED 反馈不可用")
                self._available = False
        else:
            self._available = False

    def set_state(self, state: str) -> None:
        """
        设置 LED 状态

        Args:
            state: 状态名称 ("idle" | "wakeup" | "listening" | "processing" | "speaking" | "error")
        """
        if not self._available:
            return

        # 根据状态设置 LED 效果
        if state == "idle":
            self._breathe_effect((0, 0, 255))  # 蓝色呼吸
        elif state == "wakeup":
            self._blink_effect((0, 255, 0), 0.2)  # 绿色快闪
        elif state == "listening":
            self._flow_effect((0, 255, 255))  # 青色流动
        elif state == "processing":
            self._solid_effect((255, 255, 0))  # 黄色常亮
        elif state == "speaking":
            self._pulse_effect((0, 255, 0))  # 绿色脉冲
        elif state == "error":
            self._blink_effect((255, 0, 0), 0.1)  # 红色快闪
        elif state.startswith("retry_"):
            count = int(state.split("_")[1])
            self._blink_count_effect((255, 165, 0), count)  # 橙色闪烁

    def _breathe_effect(self, color: tuple) -> None:
        """呼吸效果"""
        # 实现 LED 呼吸动画
        pass

    def _blink_effect(self, color: tuple, speed: float) -> None:
        """闪烁效果"""
        pass

    def _flow_effect(self, color: tuple) -> None:
        """流动效果"""
        pass

    def _solid_effect(self, color: tuple) -> None:
        """常亮效果"""
        if self._available:
            self._pixels.fill(color)

    def _pulse_effect(self, color: tuple) -> None:
        """脉冲效果"""
        pass

    def _blink_count_effect(self, color: tuple, count: int) -> None:
        """闪烁指定次数"""
        pass

    def is_available(self) -> bool:
        """LED 是否可用"""
        return self._available
```

#### 配置

```yaml
led_feedback:
  enabled: true                   # 是否启用 LED 反馈
  pin: 12                         # GPIO 引脚号
  led_count: 12                   # LED 数量
  brightness: 0.5                 # 亮度 (0-1)
```

#### 依赖

```bash
# LED 控制依赖（可选）
pip install adafruit-circuitpython-neopixel
pip install rpi_ws281x
```

---

### 2.4 智能尾端点检测（P1）

#### 功能描述

延长静音超时时间，拼接用户断句，避免将不完整的输入发送给 LLM。

#### 实现方案

在 `_update_listening()` 中调整超时逻辑：

```python
def _update_listening(self) -> None:
    """LISTENING 状态更新：VAD 录音"""
    try:
        # 读取音频帧
        audio_frame = self._audio_input.read_chunk()
        self._recorded_audio.append(audio_frame)

        # ... VAD 检测逻辑 ...

        # 智能尾端点检测：延长超时时间
        config = self._config.get("audio_quality", {})
        silence_threshold = config.get("smart_silence_threshold", 2.0)  # 延长到 2 秒

        # 检查录音结束条件
        current_time = time.time()
        state_duration = self.get_state_duration()

        # 条件1: 超过最大录音时长
        if state_duration >= self._max_listening_duration:
            logger.info(f"录音达到最大时长 ({self._max_listening_duration}s)")
            self.transition_to(State.PROCESSING)

        # 条件2: 检测到语音后静音超过阈值（智能延长）
        elif self._last_speech_time is not None:
            silence_duration = current_time - self._last_speech_time
            if silence_duration >= silence_threshold:
                logger.info(f"检测到静音 ({silence_duration:.1f}s)")
                self.transition_to(State.PROCESSING)

        # ... 其他逻辑 ...

    except Exception as e:
        logger.error(f"LISTENING 状态更新失败: {e}")
        self.transition_to(State.ERROR)
```

#### 配置

```yaml
audio_quality:
  smart_silence_threshold: 2.0    # 智能静音超时（秒），比基础超时更长
  min_speech_duration: 0.3        # 最小有效语音时长（秒），过滤瞬态噪音
```

---

## 3. 整体架构设计

### 3.1 状态机增强

```python
class StateMachine:
    """语音助手状态机 (Phase 1.4)"""

    def __init__(self, ...):
        # ... 现有初始化 ...

        # Phase 1.4 新增
        self._adaptive_vad = AdaptiveVAD(config.get("audio_quality", {}))
        self._led_feedback = LEDFeedback(config.get("led_feedback", {}))
        self._retry_count = 0

        # 状态转换时更新 LED
        self._transition_handlers = {
            State.IDLE: lambda: self._led_feedback.set_state("idle"),
            State.WAKEUP: lambda: self._led_feedback.set_state("wakeup"),
            State.LISTENING: lambda: self._led_feedback.set_state("listening"),
            State.PROCESSING: lambda: self._led_feedback.set_state("processing"),
            State.SPEAKING: lambda: self._led_feedback.set_state("speaking"),
            State.ERROR: lambda: self._led_feedback.set_state("error"),
        }

    def transition_to(self, new_state: State) -> None:
        """状态转换（增强版）"""
        if self._current_state == new_state:
            return

        old_state = self._current_state
        self._current_state = new_state
        self._state_start_time = time.time()

        logger.info(f"状态转换: {old_state} → {new_state}")

        # 更新 LED 反馈
        if new_state in self._transition_handlers:
            self._transition_handlers[new_state]()

        # 状态进入处理
        self._on_state_enter(new_state)

    def _update_idle(self) -> None:
        """IDLE 状态更新（增强版）"""
        try:
            # 读取音频帧
            audio_frame = self._audio_input.read_chunk()

            # 更新自适应 VAD 底噪估计
            if self._adaptive_vad:
                self._adaptive_vad.update_noise_floor(audio_frame)

            # 检测唤醒词
            if self._detector.process_frame(audio_frame):
                logger.info("🎤 检测到唤醒词！")
                self._in_conversation = True
                self._conversation_turn_count = 1
                self.transition_to(State.WAKEUP)

        except Exception as e:
            logger.error(f"IDLE 状态更新失败: {e}")
            self.transition_to(State.ERROR)

    def _update_listening(self) -> None:
        """LISTENING 状态更新（增强版）"""
        try:
            # 读取音频帧
            audio_frame = self._audio_input.read_chunk()
            self._recorded_audio.append(audio_frame)

            # 使用自适应 VAD 阈值
            audio_float = audio_frame.astype(float) / 32768.0
            rms_energy = np.sqrt(np.mean(audio_float ** 2))

            # 获取自适应阈值
            if self._adaptive_vad:
                energy_threshold = self._adaptive_vad.get_adaptive_threshold()
            else:
                energy_threshold = 0.04  # 默认阈值

            # ... 其余逻辑 ...
```

### 3.2 数据流图

```
┌───────────────────────────────────────────────────────────┐
│  IDLE 状态                                                │
│  ┌─────────────────────────────────────────────────┐     │
│  │  1. 持续采集音频                                  │     │
│  │  2. 更新自适应 VAD 底噪估计                        │     │
│  │  3. LED: 蓝色呼吸                                 │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘
                         ↓ 检测到唤醒词
┌───────────────────────────────────────────────────────────┐
│  WAKEUP 状态                                             │
│  ┌─────────────────────────────────────────────────┐     │
│  │  1. 播放唤醒反馈                                  │     │
│  │  2. LED: 绿色快闪                                 │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘
                         ↓ 播放完成
┌───────────────────────────────────────────────────────────┐
│  LISTENING 状态                                          │
│  ┌─────────────────────────────────────────────────┐     │
│  │  1. VAD 检测（自适应阈值）                       │     │
│  │  2. 智能尾端点检测（2秒超时）                     │     │
│  │  3. LED: 青色流动                                 │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘
                         ↓ 检测到静音
┌───────────────────────────────────────────────────────────┐
│  PROCESSING 状态                                         │
│  ┌─────────────────────────────────────────────────┐     │
│  │  Step 1: 音频质量检测                            │     │
│  │    - 时长-能量双重校验                           │     │
│  │    - 失败 → 分级重试（LED 橙色闪烁）            │     │
│  │                                                │     │
│  │  Step 2: STT 语音识别                            │     │
│  │                                                │     │
│  │  Step 3: 文本质量检测                            │     │
│  │    - 长度、重复字符、无效词汇                   │     │
│  │    - 失败 → 分级重试（LED 橙色闪烁）            │     │
│  │                                                │     │
│  │  Step 4-5: LLM + TTS                             │     │
│  │                                                │     │
│  │  LED: 黄色常亮                                   │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘
                         ↓ 处理完成
┌───────────────────────────────────────────────────────────┐
│  SPEAKING 状态                                            │
│  ┌─────────────────────────────────────────────────┐     │
│  │  1. 播放 TTS 回复                                 │     │
│  │  2. LED: 绿色脉冲                                 │     │
│  └─────────────────────────────────────────────────┘     │
└───────────────────────────────────────────────────────────┘
                         ↓ 播放完成
                    返回 LISTENING（多轮）
                    或 IDLE（首次对话结束）
```

---

## 4. 配置文件设计

### 4.1 config.yaml 完整配置

```yaml
# ========================================
# 音频质量检测配置 - Phase 1.4
# ========================================
audio_quality:
  # 是否启用（默认启用）
  enabled: true

  # 检测规则
  min_duration: 0.5              # 最小音频时长（秒）
  min_energy: 0.01               # 最小平均能量
  min_speech_duration: 0.3       # 最小有效语音时长（过滤瞬态噪音）

  # 智能尾端点检测
  smart_silence_threshold: 2.0   # 智能静音超时（秒）

  # 自适应 VAD
  vad:
    adaptive_enabled: true       # 启用自适应阈值
    base_threshold: 0.04         # 基础阈值
    adaptation_factor: 1.5       # 自适应系数（阈值 = 底噪 × 系数）
    noise_window_size: 100       # 底噪样本窗口大小
    reset_interval: 300          # 重置间隔（秒）

  # 重试配置
  max_retries: 3                 # 最大重试次数

  # 分级重试提示语
  retry_prompts:
    silence:
      retry_1:
        - "抱歉，没听到您的声音，能再说一遍吗？"
        - "您刚才没说话，请再试一次"
      retry_2:
        - "还是没听到，请靠近麦克风大声一点说"
        - "好像还是不太清楚，请重新说一遍"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    fragment:
      retry_1:
        - "请完整说出您的问题"
        - "话说一半啦，继续说吧"
      retry_2:
        - "请说完整一点，不要断断续续的"
        - "能完整地再说一遍吗？"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    semantic:
      retry_1:
        - "抱歉，不太明白您的意思，能再说一遍吗？"
        - "能说得更清楚一点吗？"
      retry_2:
        - "还是不太理解，请换个方式描述"
        - "能详细说明一下您的需求吗？"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    garbage:
      retry_1:
        - "抱歉，我没听清，能再说一遍吗？"
      retry_2:
        - "还是听不清楚，请重新说一遍"
      retry_3:
        - "抱歉暂时无法识别，我们换个话题吧"

    high_noise:                  # 高噪音环境提示
      - "环境有点吵，请靠近一点说"
      - "检测到背景噪音，请安静一些"

# ========================================
# 文本质量检测配置 - Phase 1.4
# ========================================
text_quality:
  enabled: true
  min_length: 2                  # 最小文本长度（字符）
  invalid_words:
    - "嗯"
    - "嗯嗯"
    - "呃"
    - "啊"
    - "喔"
    - "哦"
    - "嘿"
    - "咳"
    - "哼"
    - "那个"
    - "这个"

# ========================================
# LED 反馈配置 - Phase 1.4（可选）
# ========================================
led_feedback:
  enabled: false                 # 默认禁用，需要硬件支持
  pin: 12                        # GPIO 引脚号
  led_count: 12                  # LED 数量
  brightness: 0.5                # 亮度 (0-1)
```

---

## 5. 实施计划

### 5.1 开发任务拆解

| 阶段 | 任务 | 优先级 | 预计时间 |
|------|------|--------|----------|
| **阶段 1** | 配置文件更新 | P0 | 30分钟 |
| **阶段 2** | 自适应 VAD 实现 | P0 | 2小时 |
| **阶段 3** | 分级重试策略 | P0 | 2小时 |
| **阶段 4** | 智能尾端点检测 | P1 | 1小时 |
| **阶段 5** | LED 反馈（可选） | P1 | 2小时 |
| **阶段 6** | 状态机集成测试 | P0 | 2小时 |
| **阶段 7** | 性能优化与调试 | P0 | 2小时 |
| **阶段 8** | 文档更新 | P1 | 1小时 |

**总计**：约 12.5 小时（1.5 个工作日）

### 5.2 实施顺序

1. **第一阶段（核心功能，P0）**
   - 配置文件更新
   - 自适应 VAD 实现
   - 分级重试策略
   - 状态机集成
   - 基础测试

2. **第二阶段（增强功能，P1）**
   - 智能尾端点检测
   - LED 反馈（可选）
   - 全面测试

3. **第三阶段（优化）**
   - 性能调优
   - 参数微调
   - 文档完善

---

## 6. 测试计划

### 6.1 功能测试场景

| 场景 | 操作步骤 | 预期结果 |
|------|----------|----------|
| **自适应 VAD** | 在安静和嘈杂环境中测试 | 阈值自动调整，误触发减少 |
| **分级重试（第1次）** | 唤醒后不说话 | 提示"没听到您的声音"，重新录音 |
| **分级重试（第2次）** | 继续不说话 | 提示"请靠近麦克风大声一点"，重新录音 |
| **分级重试（第3次）** | 仍不说话 | 提示"换个话题吧"，返回 IDLE |
| **智能尾端点** | 说"今...（停顿1.5秒）...天...（停顿2秒）...气怎么样" | 完整拼接为"今天天气怎么样" |
| **LED 反馈** | 各状态切换 | LED 显示对应颜色和效果 |
| **高噪音环境** | 播放背景噪音后说话 | 提示"环境有点吵"，或正常识别 |

### 6.2 性能测试

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 自适应 VAD 延迟 | < 10ms | 计时测试 |
| LED 更新延迟 | < 50ms | 视觉检查 |
| 内存占用增加 | < 50MB | 内存监控 |
| CPU 占用增加 | < 5% | CPU 监控 |

---

## 7. 风险与挑战

### 7.1 技术风险

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| LED 依赖缺失 | 无法使用 LED 反馈 | 设为可选功能，默认禁用 |
| 自适应阈值不稳定 | 误触发增加 | 添加平滑算法，限制变化幅度 |
| 分级重试过于频繁 | 用户烦躁 | 限制最大重试次数，优化提示语 |

### 7.2 硬件依赖

| 功能 | 硬件要求 | 可选性 |
|------|----------|--------|
| 自适应 VAD | 无 | ✅ 必需 |
| 分级重试 | 无 | ✅ 必需 |
| 智能尾端点 | 无 | ✅ 必需 |
| LED 反馈 | ReSpeaker 灯带 | ⚠️ 可选 |

---

## 8. 成功指标

### 8.1 量化指标

| 指标 | 当前值 | 目标值 | 测量方法 |
|------|--------|--------|----------|
| 噪音误触发率 | ~30% | < 15% | 统计不同环境下的误触发次数 |
| LLM 无效调用率 | ~30% | < 10% | 统计发送给LLM的无效文本比例 |
| 对话完成率 | ~60% | > 80% | 统计完整对话比例 |
| 用户重试成功率 | 未知 | > 50% | 统计重试后成功的比例 |
| 端到端延迟增加 | 0ms | < 100ms | 性能测试 |

### 8.2 定性指标

- 用户能清楚看到系统状态（LED 反馈）
- 提示语更友好，知道如何重试
- 噪音环境下误触发明显减少
- 断句能被正确拼接

---

## 9. 代码改动清单

### 9.1 需要修改的文件

| 文件 | 改动类型 | 代码量 |
|------|----------|--------|
| `config.yaml` | 修改 | ~100 行 |
| `src/state_machine/machine.py` | 修改 | ~250 行 |
| `src/feedback/led_feedback.py` | 新增（可选） | ~150 行 |
| **总计（不含 LED）** | **2 个文件** | **~350 行** |

### 9.2 新增类和方法

| 类/方法 | 功能 | 优先级 |
|---------|------|--------|
| `AdaptiveVAD` | 自适应 VAD 阈值管理 | P0 |
| `_check_audio_quality()` | 音频质量检测 | P0 |
| `_check_text_quality()` | 文本质量检测 | P0 |
| `_handle_invalid_input()` | 分级重试处理 | P0 |
| `_get_retry_prompt()` | 获取分级提示语 | P0 |
| `LEDFeedback` | LED 反馈控制 | P1 |
| `_update_listening()` 增强 | 智能尾端点检测 | P1 |

---

## 10. 附录

### A. 术语表

| 术语 | 说明 |
|------|------|
| VAD | Voice Activity Detection，语音活动检测 |
| RMS | Root Mean Square，均方根能量 |
| DOA | Direction of Arrival，声源定位 |
| LED | Light Emitting Diode，发光二极管 |

### B. 参考资料

1. 现有状态机代码：`src/state_machine/machine.py`
2. Phase 1.3 交付文档：`docs/Delivery/VERSION_1.3.md`
3. ReSpeaker 4-Mic 文档：https://wiki.seeedstudio.com/ReSpeaker_4_Mic_Array_for_Raspberry_Pi/
4. NeoPiexl LED 库：https://learn.adafruit.com/neopixels-on-raspberry-pi

### C. 变更历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0 | 2026-01-22 | 初始版本（独立模块设计） | Claude |
| 1.1 | 2026-01-23 | 与现有架构整合 | Claude |
| 1.2 | 2026-01-23 | 简化设计：在状态机中直接实现 | Claude |
| 1.3 | 2026-01-23 | **纳入智能优化方案** | Claude |

---

**文档结束**
